#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn = 1e6 + 10;

const long long mod = 1e9;
long long dp[maxn];
/*
第一种解释：
 
设a[n]为和为 n 的种类数；

根据题目可知，加数为2的N次方，即 n 为奇数时等于它前一个数 n-1 的种类数 a[n-1] ，
若 n 为偶数时分加数中有无 1 讨论，即关键是对 n 为偶数时进行讨论：

1.n为奇数，a[n]=a[n-1]

2.n为偶数：

（1）如果加数里含1，则一定至少有两个1，即对n-2的每一个加数式后面 +1+1，总类数为a[n-2]；

（2）如果加数里没有1，即对n/2的每一个加数式乘以2，总类数为a[n-2]；

所以总的种类数为：a[n]=a[n-2]+a[n/2];

第二种解释：
因为如果数据要有变化的话，至少得有两个1，
如果是是奇数的话，显然这个1对于整体的情况是没有丝毫影响的，从这点继续往下想，
现在要解决的是偶数的情况：
把情况分成两类，一种是有1，一种是没有1。有1的话至少是两个，
所以这个1可以拿出来，所以这个时候情况是dp[i - 2]，
由于i－2还是偶数，所以可以用dp[i-1]来代替，那么这个时候的情况数是：
dp[i - 1]；如果分解方式里面没有1，那么至少有2（这是肯定的），
如果我们把2看成基数（因为其他的元素可以由2组成），
那么这个时候2就相当于之前的1，所以这种情况之下，总的情况数是：dp[i / 2]。 

*/
/*
我的理解：
当n是偶数时，dp[n] = dp[n-1] + 分数没有1的组合，因为dp[n-1]至少含有奇数个1
而dp[n-1]=dp[n-2] ,所以dp[n] = dp[n-1] + dp[n/2] 

*/ 
int main(){
	
	int i = 0,n = 0;
	//memset(dp,0,sizeof(dp));
	dp[1] = 1,dp[2] = 2;
	for(i = 3;i <= 1000000;++i){
		if(i % 2 == 1 ){//odd number
			dp[i] = dp[i-1];
		}else{
			dp[i] = (dp[i/2] + dp[i - 2]) % mod;
			//最后输出9位数，是%1e9,不是1e10，在这里改了好久 
		}
	}
	
	 while(scanf("%d",&n) != EOF){//多组数据，一组数据都可以过 
	 	//scanf("%d",&n);
        //printf("%I64d\n",dp[n]);//也是可以的 
        printf("%lld\n",dp[n]);
    }

	
	
	return 0;
}
